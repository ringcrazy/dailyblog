(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{321:function(e,t,a){"use strict";a.r(t);var n=a(11),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),a("h2",{attrs:{id:"babel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[e._v("#")]),e._v(" Babel")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://babeljs.io/repl",target:"_blank",rel:"noopener noreferrer"}},[e._v("将ES6代码转换成浏览器可用的代码\n"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"声明方式-let-const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明方式-let-const"}},[e._v("#")]),e._v(" 声明方式 let & const")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("for(var i = 0; i< 3; i++){\n  console.log(i)\n}\nconsole.log(i)\nconsole.log(window.i)\n")])])]),a("p",[e._v("var 不支持封闭作用域，会声明到全局作用域上，支持")]),e._v(" "),a("ul",[a("li",[e._v("1.函数作用域")]),e._v(" "),a("li",[e._v("2.全局作用域")])]),e._v(" "),a("p",[e._v("let 和 {} 配合可以产生一个作用域， let支持块级作用域，可以解决作用域污染和局部作用域的问题")]),e._v(" "),a("p",[e._v("var 在同一个作用域下可以多次声明同一个变量，而let不可以")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var a = 1\nvar a = 2\n")])])]),a("p",[e._v("var 域解释问题，变量提升, 用let解决这个问题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(a)\nvar a = 1\n")])])]),a("p",[e._v("暂存死区问题,如果作用域内有这个变量，那么这个作用域内就会绑定这个值，不会再向上查找")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let a = 1\n{\n  console.log(a)\n  let a = 2\n}\n")])])]),a("p",[e._v("通过const声明的变量不能被修改（引用空间）, 不能修改变量的地址")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const a = {name: 'zfpx'}\na.age = 9\nconsole.log(1)\n")])])]),a("h2",{attrs:{id:"解构赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[e._v("#")]),e._v(" 解构赋值")]),e._v(" "),a("p",[e._v("解构表示等号左右两边结构类似")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let [name, age] = ['珠峰', 9]\nconsole.log(name, age)\n\nlet {length} = ['珠峰', 9]\nconsole.log(length)\n\n// 关键字\nlet {name, age, default:d} = {name: '珠峰', age: 9, default: 'xx'}\n\n// 多层级\nlet [, {address: [, a]}, hobby= '游泳'] = [\n  {\n    name: 'zhufeng\n  },{\n    age: 9,\n    address: [1,2,3]\n  }]\n")])])]),a("h2",{attrs:{id:"模板字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串"}},[e._v("#")]),e._v(" 模板字符串")]),e._v(" "),a("p",[e._v("取代了原有的字符串拼接功能")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let name = '珠峰'\nlet age = 10\nlet str = 'hello ' + name + ' 今年'+ age + '岁了'\nlet str = `hello ${name} 今年${age}岁了`\n")])])]),a("p",[e._v("如何实现一个类模板字符串功能？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let name = '珠峰'\nlet age = 10\nlet str = `hello ${name} 今年${age}岁了`\nstr = str.replace(/\\$\\{([^}*])\\}/g, function(){\n  return eval(arguments[1])\n})\nconsole.log(str)\n")])])]),a("p",[e._v("带标签的模板字符 自定义模板字符串的实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let name = 'zfpx'\nlet age = 9\n\n// 第一个参数是字符串数组， 第二个参数是第一个变量\nfunction jw(){\n  let strings = arguments[0]\n\n  // Array.prototype.slice.call\n  let values = [].slice.call(argument, 1)\n  let str = ''\n  for(let i = 0; i < values.length; i++){\n    str += `${strings[i]}*${values[i]}*`\n  }\n  str += strings[strings.length -1]\n  return str\n}\nlet str = jw`hello~${name}今年${age}岁了`\n")])])]),a("h2",{attrs:{id:"其他api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他api"}},[e._v("#")]),e._v(" 其他API")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let url =  'http://www.zhufengpeixun.cn/logo.png'\n\n// 是否包含\nconsole.log(url.includes('zhufeng'))\n\n// startWith\nconsole.log(url.startWith('http'))\n\n// endWith\nconsole.log(url.endWith('png'))\n\n// padStart padEnd 补全\nsetInterval(function(){\n  let date = new Date()\n  let hour = date.getHours()\n  let minutes = date.getMinutes()\n  let seconds = date.getSeconds()\n  let str = `${hour.toString().padStart(2,0):`\n  str += `${minutes.toString().padStart(2,0):`\n  str += `${seconds.toString().padStart(2,0)`\n}, 1000)\n")])])]),a("h2",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数")]),e._v(" "),a("ul",[a("li",[e._v("1.箭头函数没有function关键字")]),e._v(" "),a("li",[e._v("2.小括号和大括号之间有个箭头")]),e._v(" "),a("li",[e._v("3.如果参数是一个，可以省略小括号")]),e._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[e._v("如果不写return，可以省略{}")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"5"}},[a("li",[e._v("如果返回的是对象，需要小括号包裹")])])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function a(c){\n  return function (d){\n    return c + d\n  }\n}\n\nlet a = c => d => c + d\nconsole.log(a(1)(2))\n")])])]),a("p",[e._v("解决this问题")]),e._v(" "),a("ul",[a("li",[e._v("1.var that = this")]),e._v(" "),a("li",[e._v("2.bind")]),e._v(" "),a("li",[e._v("3.箭头函数")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n// 对象不是作用域， let声明的也不会被声明到全局上\n// 箭头函数中没有this，也没有arguments\nlet obj = {\n  b: 1,\n  a: function(){\n    setTimeout(()=>{\n      console.log(this)\n    })\n  }\n}\nobj.a()\n")])])]),a("p",[e._v("面试题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let a = 1\nlet obj = {\n  a: 2\n  b: ()=>{\n    console.log(this.a)\n  }\n}\nobj.b()\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let fn = (...arguments) => {\n  let args = arguments.slice(1)\n  console.log(args)\n}\nfn('x', 1,2,3,4,5)\n")])])]),a("p",[e._v("函数中可以赋予默认参数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let fn = (a=1, b=2) => {\n  console.log(a,b)\n}\nfn()\n")])])]),a("h2",{attrs:{id:"展开运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#展开运算符"}},[e._v("#")]),e._v(" 展开运算符")]),e._v(" "),a("p",[e._v("... 是浅拷贝")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let name = {name: 'zfpx'}\nlet age = {age: 9}\nlet school = {..name, ...age}\n")])])]),a("p",[e._v("深拷贝的实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("JSON的问题\nlet obj = {a: 1, fn: function(params){}, t: /a/, d: new Date()}\n")])])]),a("p",[e._v("代码实现，保留继承关系，实现各种类型的拷贝 实现递归拷贝")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function deepClone(obj){\n  if(typeof obj !== 'object') return obj\n  if(obj == null) return null\n  if(obj instanceof Date) return new Date(obj)\n  if(obj instanceof RegExp) return new RegExp(obj)\n\n  let o = new obj.constructor() // 保留类的继承关系\n  for(let key in obj){\n    o[key] = typeof obj[key] === 'object' ? deepClone(obj[key]): obj[key]\n  }\n\n}\n\ndeepClone(new Date())\n")])])]),a("h2",{attrs:{id:"数组的常见方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组的常见方法"}},[e._v("#")]),e._v(" 数组的常见方法")]),e._v(" "),a("h3",{attrs:{id:"reduce-收敛、叠加"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reduce-收敛、叠加"}},[e._v("#")]),e._v(" reduce 收敛、叠加")]),e._v(" "),a("p",[e._v("reduce返回的结果是叠加后的结果，函数的返回结果会作为下一次循环的prev,\n如果有初始值，currIndex从0开始，若没有初始值，currIndex从1开始\ncurrIndex表示next的索引")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let result = [1,2,3,4,5].reduce((prev, next, currIndex, arr)=>{\n  // 求平均数\n  if(currIndex === arr.length -1){\n    return (prev+next)/ arr.length\n  }\n  console.log(prev, next, currIndex, arr)\n  return prev + next\n})\n")])])]),a("p",[e._v("初始值的作用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let total = [{price: 10}, {price: 20}, {price: 30}].reduce((prev,next,currIndex, arr)=>{\n  return prev + next.price\n}, 0)\n")])])]),a("p",[e._v("reduce的实现原理")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Array.prototype.myReduce = function(fn, prev){\n  for(let i=0; i< this.length; i++){\n    if(typeof prev === 'undefined'){\n      prev = fn(this[i], this[i+1], i+1, this)\n      i++\n    }else{\n      prev = fn(prev, this[i], i, this)\n    }\n  }\n  return prev\n}\n")])])]),a("p",[e._v("展平数组,将二维数组转换为一维数组")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let flat = [[1,2,3],[4,5,6]].reduce((prev,next,index,array)=>{\n  return [..prev, ...next]\n})\n")])])]),a("h3",{attrs:{id:"foreach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[e._v("#")]),e._v(" forEach")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Array.prototype.forEach = function(fn, index){\n  for(let i=0; i<this.length; i++){\n    fn(this[i], i)\n  }\n};\n[1,2,3].forEach((item,index)=>{\n  console.log(item, index)\n})\n")])])]),a("h3",{attrs:{id:"map返回值，是一个新的数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map返回值，是一个新的数组"}},[e._v("#")]),e._v(" map返回值，是一个新的数组")]),e._v(" "),a("h3",{attrs:{id:"filter过滤，如果返回true表示留下，返回false表示删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#filter过滤，如果返回true表示留下，返回false表示删除"}},[e._v("#")]),e._v(" filter过滤，如果返回true表示留下，返回false表示删除")]),e._v(" "),a("h3",{attrs:{id:"find查找，返回查找的那一项，如果没有返回undefined-找到后就不会再查找了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#find查找，返回查找的那一项，如果没有返回undefined-找到后就不会再查找了"}},[e._v("#")]),e._v(" find查找，返回查找的那一项，如果没有返回undefined,找到后就不会再查找了")]),e._v(" "),a("h3",{attrs:{id:"some-找到后返回true，找false可以用every-找到后就不会再找了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#some-找到后返回true，找false可以用every-找到后就不会再找了"}},[e._v("#")]),e._v(" some,找到后返回true，找false可以用every,找到后就不会再找了")]),e._v(" "),a("h3",{attrs:{id:"from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from"}},[e._v("#")]),e._v(" from")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 将常见的类数组转换成数组\n")])])]),a("h2",{attrs:{id:"对象的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的方法"}},[e._v("#")]),e._v(" 对象的方法")]),e._v(" "),a("p",[e._v("Object.assign() // 浅拷贝")]),e._v(" "),a("p",[e._v("Object.setPrototypeOf()")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let obj1 = {name: 'zfpe'}\nlet obj2 = {age: 9}\nobj1.__proto__ = obj2\nObject.setPrototypeOf(obj1, obj2)\nObject.getPrototypeOf(obj1)\n")])])]),a("p",[e._v("可以通过super关键字获取到父属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let obj2 = {\n  name: 'jw',\n  age: 10\n}\nlet obj = {\n  name: 'zfpx',\n  getPName(){\n    return super.name\n  },\n  __proto__: obj2\n}\nconsole.log(obj.getPName())\n")])])]),a("h2",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[e._v("#")]),e._v(" 类")]),e._v(" "),a("p",[e._v("类的继承 三种属性， 公有，私有， 静态（ES6）")]),e._v(" "),a("p",[e._v("1.继承私有属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Parent(){\n  // 构造函数中的this通过new调用的，那么this指代的是实例, 实例私有\n  this.name = 'parent'\n}\n\n// 实例公有\nParent.prototype.eat = function() {\n  console.log('eat')\n}\n// Parent.prototype.constructor = Parent\n\nlet parent = new Parent()\n// parent.__proto__.eat() // 会先去找私有，如果找不到会去找公有\n\nfunction Child(){\n  this.age = 9\n  Parent.call(this) // 1.继承私有属性\n}\n\n")])])]),a("p",[e._v("2.继承公有属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Parent(){\n  this.name = 'parent'\n}\nParent.prototype.eat = function() {\n  console.log('eat')\n}\n\nfunction Child(){\n  this.age = 9\n}\n\nChild.prototype.__proto__ = Parent.prototype // 2.1\nObject.setPrototypeOf(Child.prototype, Parent.prototype) // 2.2 === 2.1\n\n// Object.create\n\nChild.prototype = Object.create(Parent.prototype, {constructor: {value: Child}})\n\n")])])]),a("p",[e._v("create的实现原理：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function create(parentPrototype, props){\n  let Fn = function(){}\n  Fn.prototype = parentPrototype\n  let fn = new Fn()\n  for(let key in props){\n    Object.defineProperty(fn, key, {\n      ...props[key],\n      enumerable: true\n    })\n  }\n  return fn\n}\n")])])]),a("p",[e._v("3.继承公有和私有属性\nChild.prototype = new Parent() // 不会使用这种方式")]),e._v(" "),a("h3",{attrs:{id:"object-defineproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let a = {}\nObject.defineProperty(a, 'name', {\n  enumerable: true, // 表示这个属性是否可以被枚举\n  configurable: true, // 表示这个属性是否可以被删除\n  // writable: true, // 表示这个属性是否可写\n  // value: 1， // 可以替换成get/set\n  get(){\n    return 1\n  },\n  set(val){\n\n  }\n})\n")])])]),a("h3",{attrs:{id:"es6中的类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6中的类"}},[e._v("#")]),e._v(" ES6中的类")]),e._v(" "),a("ul",[a("li",[e._v("1.类只能new")]),e._v(" "),a("li",[e._v("2.类可以继承公有、私有、静态方法")]),e._v(" "),a("li",[e._v("3.父类的构造函数中返回了一个引用类型，会把这个引用类型返回作为类的实例")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class Parent{\n  this.name = 'zfpx'\n}\n\nclass Child{\n  constructor(){\n    this.age  = 9 // 私有属性\n  }\n\n  static a(){\n    return 1\n  }\n  smoking(){ // 原型上的方法\n\n  }\n}\n\nlet child = new Child()\nChild.a()\nchild.smoking()\n")])])]),a("h3",{attrs:{id:"es5中的类-类的编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es5中的类-类的编译"}},[e._v("#")]),e._v(" ES5中的类,类的编译")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let\n")])])]),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),a("p",[e._v("Promise是一种异步流程的控制手段")]),e._v(" "),a("ul",[a("li",[e._v("1.异步回调")]),e._v(" "),a("li",[e._v("2.链式调用，第一个的输出是第二个的输入")]),e._v(" "),a("li",[e._v("3.可以支持多个并发，获取并发请求中的数据")])]),e._v(" "),a("p",[e._v("// Promise只有一个参数，叫excutor执行器，默认new时就会调用\n每个promise的实例上都有一个then方法，then方法中有两个回调，\npromise发生错误，会走错误回调")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let p = new Promise((resolve, reject) =>{ // 默认excutor是同步执行的\n  console.log(1)\n})\nconsole.log(2)\n\n// then方法是异步调用的\np.then((success)=>{},(err)=>{})\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);